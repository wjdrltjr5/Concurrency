# 재고시스템으로 알아보는 동시성이슈

## Synchronized
- 트랜잭션 어노테이션 사용시 프록시 객체 생성으로 인한 시간차이로 완벽하게 해결하지 못한다.
- 트랜잭션 어노테이션을 제거하고 사용하면 더티체킹 못하므로 수정한거 saveAndFlush 해줘야함
- Synchronized 하나의 프로세스 안에서만 보장됨, 서버가 여러대일경우 데이터에 접근을 여러곳에서
 할 수 있으므로 위험

## RDB(MYSQL)
- Pessimisic Lock(비관적 잠금,선점잠금) : 실제로 데이터에 Lock을 걸어서 정합성을 맞추는 방법.<br>
exclusive lock을 걸게되며 다른 트랙잭션에서는 lock이 헤제되기 전에 데이터를 가져갈 수 없게 됨(데드락에 걸릴 수 있기에 주의 서로서로 하나를 잠금하고 요구)<br>
그래서 보통 잠금을 구할때 최대 대기시간을 지정함<br>
  (ex. 운영자가 배송지 정보를 조회하고 배송상태로 변경하는사이 고객이 배송지 정보를
변경했을때, 운영자는 기존 배송지 정보를 가지고 배송을 시작하는 문제를 해결할 수 없음 -> 비선점으로 해결)

  
- Optimistic Lock(낙관적잠금,비선점잠금) : 실제로 Lock을 이용하지 않고 버전을 이용함으로써 정합성을 맞추는 방법.<br> 
먼저 데이터를 읽은 후에 update를 수행할 때 현재 내가 읽은 버전이 맞는지 확인하여 업데이트<br>
내가 읽은 버전에서 수정사항이 있을경우 application에서 다시 읽은 후에 작업 수행<br> 
version전용 컬럼 만들고 version어노테이션 붙임

- Named Lock : 이름을 가진 metadata locking입니다.<br>
이름을 가진 lock을 획득한 후 헤제할때까지 다른 세션은 이 lock을 획득할 수 없도록 합니다.<br>
트랜잭션 끝날때 자동 헤제되지 않으므로 명시적으로 헤제하거나 선점 시간이 끝나야 헤제됨

---
- 오프라인 선점 잠금
  

## Redis
- Lettuce
  - setnx 명령어를 활용하여 분산락 구현 (Named lock과 비슷 단 session관리 신경 안써도 됨)
  - spin lock방식
- Redisson
  - pub-sub 기반으로 Lock 구현 제공
